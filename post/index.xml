<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 有鸟止南方之阜</title>
    <link>https://kphn.github.io/post/</link>
    <description>Recent content in Posts on 有鸟止南方之阜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 03 Aug 2019 15:51:09 +0800</lastBuildDate>
    
	<atom:link href="https://kphn.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>网络编程</title>
      <link>https://kphn.github.io/post/2019/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sat, 03 Aug 2019 15:51:09 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>客户端-服务器编程模型 每个网络应用都是基于客户端-服务器模型的。基于这个模型，一个应用是由一个服务器进程和一个或多个客户端进程组成。服务器管</description>
    </item>
    
    <item>
      <title>分布式锁</title>
      <link>https://kphn.github.io/post/2019/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Fri, 05 Jul 2019 08:05:08 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>背景 在分布式环境下，需要控制多个节点对同一个资源的并发访问，此时本地的加锁已经不能满足需要。为了实现在分布式环境下的锁。 使用场景 效率:使用分</description>
    </item>
    
    <item>
      <title>部署ngrok</title>
      <link>https://kphn.github.io/post/2019/%E9%83%A8%E7%BD%B2ngrok/</link>
      <pubDate>Sun, 30 Jun 2019 15:37:14 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E9%83%A8%E7%BD%B2ngrok/</guid>
      <description>ngrok ngrok可以让本地的web服务或tcp服务和外部建立一个安全的通道，使得外网可以访问本地的计算机服务。不仅可以用来暴露内网的http给外</description>
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://kphn.github.io/post/2019/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:41:18 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      <description>定义 合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Pri</description>
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://kphn.github.io/post/2019/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:27:57 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>定义 迪米特法则（Law of Demeter）：又称最少知识原则（Least Knowledge Principle，LKP），只与你的直接朋友交谈，不跟“陌生人”说</description>
    </item>
    
    <item>
      <title>接口隔离原则</title>
      <link>https://kphn.github.io/post/2019/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:16:33 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      <description>定义 接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小和更具体的接口，让接口中只包含客户</description>
    </item>
    
    <item>
      <title>单一职责原则</title>
      <link>https://kphn.github.io/post/2019/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</link>
      <pubDate>Fri, 28 Jun 2019 08:05:42 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</guid>
      <description>定义 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则：规定一个类应该且仅有一个引起它变化的原因，否则类应该被拆分。 该</description>
    </item>
    
    <item>
      <title>依赖倒置原则</title>
      <link>https://kphn.github.io/post/2019/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 27 Jun 2019 08:42:55 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</guid>
      <description>定义 依赖倒置原则（Dependence Inversion Principle，DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，</description>
    </item>
    
    <item>
      <title>开放闭合原则</title>
      <link>https://kphn.github.io/post/2019/open-close/</link>
      <pubDate>Wed, 26 Jun 2019 23:17:56 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/open-close/</guid>
      <description>开闭原则 定义 OCP（Open Closed Principle）：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://kphn.github.io/post/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 26 Jun 2019 08:25:28 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 设计模式是前辈们对于代码开发经验的总结，是解决特定问题的一种固定套路。本质上还是对面向对象设计原则的实际运用，是对类的封装性、继承性和多</description>
    </item>
    
  </channel>
</rss>