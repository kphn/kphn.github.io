<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>有鸟止南方之阜</title>
    <link>https://kphn.github.io/</link>
    <description>Recent content on 有鸟止南方之阜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 30 Jun 2019 15:37:14 +0800</lastBuildDate>
    
        <atom:link href="https://kphn.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://kphn.github.io/about/</link>
      <pubDate>Thu, 20 Jun 2019 21:38:52 +0800</pubDate>
      
      <guid>https://kphn.github.io/about/</guid>
      
        <description>&lt;p&gt;记录学习生活感悟的Blog，之前写的东西都比较零碎且没有全部记录在博客中。
希望之后能认真的耕耘好着一亩三分地，认真记录好整理好自己的学习心得。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>部署ngrok</title>
      <link>https://kphn.github.io/post/%E9%83%A8%E7%BD%B2ngrok/</link>
      <pubDate>Sun, 30 Jun 2019 15:37:14 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E9%83%A8%E7%BD%B2ngrok/</guid>
      
        <description>

&lt;h2 id=&#34;ngrok&#34;&gt;ngrok&lt;/h2&gt;

&lt;p&gt;ngrok可以让本地的web服务或tcp服务和外部建立一个安全的通道，使得外网可以访问本地的计算机服务。不仅可以用来暴露内网的http给外网使用，还可以从外网来ssh到本机开发环境。ngrok可以通过官方的服务来连接，也可以自己来。下面介绍下私有的ngrok服务的搭建工作。&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;搭建ngrok服务需要一个&lt;strong&gt;外网服务器&lt;/strong&gt;以及一个已经解析到了该机器的&lt;strong&gt;域名&lt;/strong&gt;（假定为test.site）,国内可以在阿里云购买相关服务：&lt;a href=&#34;https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mwdh54s4&#34;&gt;阿里云&lt;/a&gt;。注意：下文中用到的所有端口，如果启用了iptables规则，都需要放行，如果在阿里云中，需要设置&lt;strong&gt;安全组规则&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;依赖项&#34;&gt;依赖项&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;ngrok使用go语言开发，所以首先要 安装go语言：&lt;a href=&#34;https://golang.org/doc/install&#34;&gt;https://golang.org/doc/install&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;下载代码：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a href=&#34;https://github.com/inconshreveable/ngrok.git&#34;&gt;https://github.com/inconshreveable/ngrok.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成ssl证书：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cd ngrok&lt;/p&gt;

&lt;p&gt;NGROK_DOMAIN=&amp;ldquo;test.site&amp;rdquo;&lt;/p&gt;

&lt;p&gt;openssl genrsa -out base.key 2048&lt;/p&gt;

&lt;p&gt;openssl req -new -x509 -nodes -key base.key -days 10000 -subj &amp;ldquo;/CN=$NGROK_DOMAIN&amp;rdquo; -out base.pem&lt;/p&gt;

&lt;p&gt;openssl genrsa -out server.key 2048&lt;/p&gt;

&lt;p&gt;openssl req -new -key server.key -subj &amp;ldquo;/CN=$NGROK_DOMAIN&amp;rdquo; -out server.csr&lt;/p&gt;

&lt;p&gt;openssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt&lt;/p&gt;

&lt;p&gt;cp base.pem assets/client/tls/ngrokroot.crt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;sudo make release-server release-client&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时在bin目录下应该有ngrok和ngrokd两个可执行文件。&lt;/p&gt;

&lt;p&gt;如果需要交叉编译：先设置好GOOS与GOARCH变量&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Linux 平台 32 位系统：GOOS=linux GOARCH=386&lt;/p&gt;

&lt;p&gt;Linux 平台 64 位系统：GOOS=linux GOARCH=amd64&lt;/p&gt;

&lt;p&gt;Windows 平台 32 位系统：GOOS=windows GOARCH=386&lt;/p&gt;

&lt;p&gt;Windows 平台 64 位系统：GOOS=windows GOARCH=amd64&lt;/p&gt;

&lt;p&gt;MAC 平台 32 位系统：GOOS=darwin GOARCH=386&lt;/p&gt;

&lt;p&gt;MAC 平台 64 位系统：GOOS=darwin GOARCH=amd64&lt;/p&gt;

&lt;p&gt;如需要编译window 64位版本：
GOOS=windows GOARCH=amd64 make release-client&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务端启动：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup ./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&amp;ldquo;test.site&amp;rdquo; -httpAddr=&amp;rdquo;:8081&amp;rdquo; -httpsAddr=&amp;rdquo;:8082&amp;rdquo; &amp;amp;&lt;/p&gt;

&lt;p&gt;示例中8081用来连接http请求，8082用来连接https请求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;客户端启动：&lt;/p&gt;

&lt;p&gt;将编译好的client版本下载到指定的机器上之后，配置启动文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;server_addr: test.site:4443			//4443为ngrok控制tunnel
trust_host_root_certs: false		//如果不需要使用TLS，可以将此变量设置为你false
tunnels:
  client:
    subdomain: pub
    proto:
      http: 8080
  ssh:
    remote_port: 2022
    proto:
      tcp: 22
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;./ngrok -log=stdout -config=ngrok.yml start ssh client&amp;amp;  启动客户端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，会把本机的8080端口的服务映射到服务端pub.test.site:8081端口，便可以用来访问客户端的8080端口的服务了。&lt;/p&gt;

&lt;p&gt;tcp tunnel将22端口映射到服务端的2022端口，便可以ssh user@test.site -p2022 来访问客户端的ssh服务了。&lt;/p&gt;

&lt;p&gt;开机启动ngrok client：&lt;/p&gt;

&lt;p&gt;首先编写启动脚本 ngrok.sh：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/ngrok-client
./ngrok -log=stdout -config=ngrok.yml start ssh&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再配置systemd ngrok service文件 /usr/lib/systemd/system/ngrok.service；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=ngrok service

[Service]
Type=forking
ExecStart=/bin/bash /path/to/ngrok.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable ngrok.service
systemctl start ngrok.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务就可以开机启动了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://kphn.github.io/post/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:41:18 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;如果要使用继承关心，必须严格遵循里氏替换原则。&lt;/code&gt;合成复用原则同里氏替换原则是相辅相成的，两者都是开闭原则的具体实现规范。&lt;/p&gt;

&lt;h2 id=&#34;重要性&#34;&gt;重要性&lt;/h2&gt;

&lt;p&gt;通常类的复用分为继承复用和组合复用两种，继承复用虽然有简单和易实现的优点，但也存在以下缺点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;继承复用&lt;strong&gt;&lt;em&gt;破坏了类的封装性&lt;/em&gt;&lt;/strong&gt;。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子类与父类的耦合度高&lt;/strong&gt;。父类的实现的任何改变都会&lt;strong&gt;&lt;em&gt;导致子类的实现发生变化&lt;/em&gt;&lt;/strong&gt;，这不利于类的扩展与维护。&lt;/li&gt;
&lt;li&gt;它限制了复用的灵活性。从父类继承而来的实现是静态的，在&lt;strong&gt;&lt;em&gt;编译时已经定义&lt;/em&gt;&lt;/strong&gt;，所以在运行时不可能发生变化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。&lt;/li&gt;
&lt;li&gt;新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。&lt;/li&gt;
&lt;li&gt;复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;共介绍了7种设计原则，它们分别为&lt;a href=&#34;https://kphn.github.io/post/open-close/&#34;&gt;开闭原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/里氏替换原则&#34;&gt;里氏替换原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/依赖倒置原则/&#34;&gt;依赖倒置原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/单一职责/&#34;&gt;单一职责原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/接口隔离原则&#34;&gt;接口隔离原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/迪米特法则/&#34;&gt;迪米特法则&lt;/a&gt;和本节所介绍的合成复用原则。&lt;/p&gt;

&lt;p&gt;这 7 种设计原则是软件&lt;a href=&#34;https://kphn.github.io/post/设计模式/&#34;&gt;设计模式&lt;/a&gt;必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://kphn.github.io/post/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:27:57 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;迪米特法则（Law of Demeter）：又称最少知识原则（Least Knowledge Principle，LKP），只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。&lt;/p&gt;

&lt;p&gt;迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;降低了类之间的耦合度，提高了模块的相对独立性。&lt;/li&gt;
&lt;li&gt;由于亲和度降低，从而提高了类的可复用率和系统的扩展性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，过度使用迪米特法则会使系统产生大量的&lt;strong&gt;中介类(Agent)&lt;/strong&gt;，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在采用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。&lt;/p&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;从迪米特法则的定义和特点可知，它强调以下两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从依赖者的角度来说，只依赖应该依赖的对象。&lt;/li&gt;
&lt;li&gt;从被依赖者的角度说，只暴露应该暴露的方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，在运用迪米特法则时要注意以下 6 点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。&lt;/li&gt;
&lt;li&gt;在类的结构设计上，尽量降低类成员的访问权限。&lt;/li&gt;
&lt;li&gt;在类的设计上，优先考虑将一个类设置成不变类。&lt;/li&gt;
&lt;li&gt;在对其他类的引用上，将引用其他对象的次数降到最低。&lt;/li&gt;
&lt;li&gt;不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。&lt;/li&gt;
&lt;li&gt;谨慎使用序列化（Serializable）功能。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>接口隔离原则</title>
      <link>https://kphn.github.io/post/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:16:33 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小和更具体的接口，让接口中只包含客户感兴趣的方法。定义：客户端不应该被迫依赖于它不适用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。&lt;/p&gt;

&lt;p&gt;以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。&lt;/p&gt;

&lt;p&gt;接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。&lt;/li&gt;
&lt;li&gt;单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;p&gt;接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。&lt;/li&gt;
&lt;li&gt;接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。&lt;/li&gt;
&lt;li&gt;如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。&lt;/li&gt;
&lt;li&gt;使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。&lt;/li&gt;
&lt;li&gt;能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑&lt;/li&gt;
&lt;li&gt;为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。&lt;/li&gt;
&lt;li&gt;了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，深入了解业务逻辑。&lt;/li&gt;
&lt;li&gt;提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>单一职责原则</title>
      <link>https://kphn.github.io/post/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</link>
      <pubDate>Fri, 28 Jun 2019 08:05:42 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则：规定一个类应该且仅有一个引起它变化的原因，否则类应该被拆分。&lt;/p&gt;

&lt;p&gt;该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；&lt;/li&gt;
&lt;li&gt;当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全部包含进来，从而造成冗余代码或代码的浪费。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;p&gt;单一职责原则的核心就是&lt;strong&gt;控制类的粒度大小&lt;/strong&gt;、将对象&lt;strong&gt;解耦、提高其内聚性&lt;/strong&gt;。如果遵循单一职责原则将有以下优点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;降低类的复杂度。一个类只负责一项职责。&lt;/li&gt;
&lt;li&gt;提高类的可读性。&lt;/li&gt;
&lt;li&gt;提高系统的可维护性。&lt;/li&gt;
&lt;li&gt;变更引起的风险降低。当修改一个功能时，可以显著降低对其他功能的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;单一职责原则是最简单但又比较难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或者模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>依赖倒置原则</title>
      <link>https://kphn.github.io/post/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 27 Jun 2019 08:42:55 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;依赖倒置原则（Dependence Inversion Principle，DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是&lt;code&gt;面向接口编程，不要面向实现编程&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节搭建起来的架构稳定的多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。&lt;/p&gt;

&lt;p&gt;使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。&lt;/p&gt;

&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;依赖倒置降低了类间的耦合性&lt;/li&gt;
&lt;li&gt;依赖倒置提高了系统的稳定性&lt;/li&gt;
&lt;li&gt;依赖倒置减少并行开发引起的风险&lt;/li&gt;
&lt;li&gt;依赖倒置提高了代码的可读性和可维护性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;依赖倒置原则的目的是通过面向接口的编程来降低类间的耦合性&lt;/code&gt;，需要遵循以下几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每个类尽量提供接口或抽象类，或者两者都具备&lt;/li&gt;
&lt;li&gt;变量的声明类型尽量是接口或者是抽象类&lt;/li&gt;
&lt;li&gt;任何类都不应该从抽象类派生&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用继承时尽量遵循里氏替换原则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package principle;
public class DIPtest
{
public static void main(String[] args)
{
    Customer wang=new Customer();
    System.out.println(&amp;quot;顾客购买以下商品：&amp;quot;); 
    wang.shopping(new ShaoguanShop()); 
    wang.shopping(new WuyuanShop());
}
}
//商店
interface Shop
{
public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
public String sell()
{
    return &amp;quot;韶关土特产：香菇、木耳……&amp;quot;; 
} 
}
//婺源网店
class WuyuanShop implements Shop
{
public String sell()
{
    return &amp;quot;婺源土特产：绿茶、酒糟鱼……&amp;quot;; 
}
} 
//顾客
class Customer
{
public void shopping(Shop shop)
{
    //购物
    System.out.println(shop.sell()); 
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>开放闭合原则</title>
      <link>https://kphn.github.io/post/open-close/</link>
      <pubDate>Wed, 26 Jun 2019 23:17:56 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/open-close/</guid>
      
        <description>

&lt;h2 id=&#34;开闭原则&#34;&gt;开闭原则&lt;/h2&gt;

&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;

&lt;p&gt;OCP（Open Closed Principle）：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）。&lt;/p&gt;

&lt;p&gt;这里的软件实体包括以下几个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;项目中划分出的模块&lt;/li&gt;
&lt;li&gt;类与接口&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。&lt;/p&gt;

&lt;h3 id=&#34;作用与实现方法&#34;&gt;作用与实现方法&lt;/h3&gt;

&lt;p&gt;开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。
可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://kphn.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 26 Jun 2019 08:25:28 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;设计模式是前辈们对于代码开发经验的总结，是解决特定问题的一种固定套路。本质上还是对面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。设计模式最终要做到的就是&lt;strong&gt;将变化的部分和不变的部分隔离开来&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;设计模式有两个核心理念：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Program to an “interface”,not an &amp;ldquo;implementation&amp;rdquo;

&lt;ol&gt;
&lt;li&gt;使用者不需要知道数据类型，结构，算法的细节&lt;/li&gt;
&lt;li&gt;使用者不需要知道实现细节，只需要知道提供的接口&lt;/li&gt;
&lt;li&gt;利于抽象，封装，动态绑定，多态&lt;/li&gt;
&lt;li&gt;符合面向对象的特质和理念&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Favor &amp;lsquo;object composition&amp;rsquo; over &amp;lsquo;class inheritance&amp;rsquo;&amp;rdquo;

&lt;ol&gt;
&lt;li&gt;继承需要给子类暴漏一些父类的设计和实现细节&lt;/li&gt;
&lt;li&gt;父类实现的改变会造成子类也需要改变&lt;/li&gt;
&lt;li&gt;我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法&lt;/li&gt;
&lt;li&gt;继承更多的应该是为了多态&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tips&#34;&gt;TIPS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;封装变化&lt;/li&gt;
&lt;li&gt;多用组合，少用继承&lt;/li&gt;
&lt;li&gt;针对接口编程，不针对实现编程&lt;/li&gt;
&lt;li&gt;将系统中变化的部分抽离出来封装&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导航&#34;&gt;导航&lt;/h2&gt;

&lt;p&gt;接下来，我将具体的深入到每个设计模式当中去，去探究其使用场景&lt;/p&gt;

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;面向对象设计原则

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/open-close/&#34;&gt;开放闭合原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/里氏替换原则&#34;&gt;里氏替换原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/依赖倒置原则/&#34;&gt;依赖倒置原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/单一职责/&#34;&gt;单一职责原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/接口隔离原则&#34;&gt;接口隔离原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/迪米特法则/&#34;&gt;迪米特法则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/合成复用原则/&#34;&gt;合成复用原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;设计模式详解

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;创建性模式&lt;/li&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;行为型模式

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; [观察者模式]()&lt;/label&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/design_pattern/&#34;&gt;Java设计模式：23种设计模式全面解析（超级详细）&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
