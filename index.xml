<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>有鸟止南方之阜</title>
    <link>https://kphn.github.io/</link>
    <description>Recent content on 有鸟止南方之阜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 03 Aug 2019 15:51:09 +0800</lastBuildDate>
    
        <atom:link href="https://kphn.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://kphn.github.io/about/</link>
      <pubDate>Thu, 20 Jun 2019 21:38:52 +0800</pubDate>
      
      <guid>https://kphn.github.io/about/</guid>
      
        <description>&lt;p&gt;记录学习生活感悟的Blog，之前写的东西都比较零碎且没有全部记录在博客中。
希望之后能认真的耕耘好着一亩三分地，认真记录好整理好自己的学习心得。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>网络编程</title>
      <link>https://kphn.github.io/post/2019/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sat, 03 Aug 2019 15:51:09 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      
        <description>

&lt;h2 id=&#34;客户端-服务器编程模型&#34;&gt;客户端-服务器编程模型&lt;/h2&gt;

&lt;p&gt;每个网络应用都是基于&lt;code&gt;客户端-服务器模型&lt;/code&gt;的。基于这个模型，一个应用是由一个服务器进程和一个或多个客户端进程组成。服务器管理者某种资源，并利用这种资源为其他客户端提供服务。
常见的类型有：&lt;strong&gt;web服务器&lt;/strong&gt;，&lt;strong&gt;FTP服务器&lt;/strong&gt;，&lt;strong&gt;电子邮件服务器&lt;/strong&gt;等。&lt;/p&gt;

&lt;h2 id=&#34;套接字编程&#34;&gt;套接字编程&lt;/h2&gt;

&lt;p&gt;套接字接口流程图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kphn.github.io/image/套接字接口.svg&#34; alt=&#34;socket&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;套接字函数&#34;&gt;套接字函数&lt;/h3&gt;

&lt;p&gt;​   &lt;code&gt;int socket(int domain,int type,int protocol)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果想要使套接字成为连接的一个端点，使用 &lt;code&gt;clinetfd = Socket(AF_INET,SOCK_STREAM,0)&lt;/code&gt;,AF_INET代表正在使用32位IP地址，而SOCK_STREAM表示这个套接字是连接的一个端点。socket返回的clientfd描述符仅是部分打开的，还不能用于读写。&lt;/p&gt;

&lt;h3 id=&#34;connect函数&#34;&gt;connect函数&lt;/h3&gt;

&lt;p&gt;客户端通过调用connect函数来建立和服务器的连接。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;int connect(int clientfd,const struct sockaddr *addr,socklen_t addr)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;connect函数试图与套接字地址为addr的服务器建立一个因特网连接，其中addrlen是sizeof（sockaddr_in）。connect函数会阻塞，一直到连接成功建立或者发生错误。如果成功，clientfd描述符现在就可以准备好读写了。&lt;/p&gt;

&lt;h3 id=&#34;bind函数&#34;&gt;bind函数&lt;/h3&gt;

&lt;p&gt;服务器用bind、listen和accept等套接字来和客户端建立连接。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;bind函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来。&lt;/p&gt;

&lt;h3 id=&#34;listen函数&#34;&gt;listen函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;int listen(int socktd,int backlog)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;listen函数将sockfd从一个主动套接字转化为一个监听套接字(listening socket),该套接字可以接受来自客户端的连接请求。backlog参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。&lt;/p&gt;

&lt;h3 id=&#34;accept函数&#34;&gt;accept函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;int accept(int listenfd,struct sockaddr *addr,int *addrlen)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;accept函数等待来自客户端的请求连接到达侦听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个*已连接描述符*，这个描述符可被用来利用Unix I/O函数与客户端通信。&lt;/p&gt;

&lt;p&gt;监听描述符vs已连接描述符：监听描述符是作为客户端连接请求中的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建立起来的一个端点。服务器每次接受连接请求时都会创建一次，它只存在服务器为一个客户端服务的过程中。
&lt;img src=&#34;https://kphn.github.io/image/connfd.png&#34; alt=&#34;socket&#34; /&gt;&lt;/p&gt;

&lt;p&gt;套接字接口区分监听描述符和已连接描述符的一个重要的原因就是：使用连接描述符可以建立并发服务器，它能够同时处理许多客户端连接。例如：每次一个连接请求到达监听描述符时，可以派生出一个新的进程，它通过已连接描述符和客户端通信。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//简单的单连接无并发的程序
void echo(int connfd);
int main(int argc,char **argv)
{
  int listenfd,connfd;
  socklen_t clientfd;
  struct sockaddr_storage clientaddr;
  char client_hostname[MAXLINE],client_port[MAXLINE];
  
  if (argc!=2){
    exit(0);
  }
  
  listenfd = Open_listenfd(argv[1]);
  while(1){
    clientlen = sizeof(struct sockaddr_storage);
    connfd = Accept(listenfd,(SA *)&amp;amp;clientaddr, &amp;amp;clientlen);
    echo(connfd);
    Close(connfd);
  }
  exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>分布式锁</title>
      <link>https://kphn.github.io/post/2019/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Fri, 05 Jul 2019 08:05:08 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      
        <description>

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;在分布式环境下，需要控制多个节点对同一个资源的并发访问，此时本地的加锁已经不能满足需要。为了实现在分布式环境下的锁。&lt;/p&gt;

&lt;h3 id=&#34;使用场景&#34;&gt;使用场景&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。&lt;/li&gt;
&lt;li&gt;正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。&lt;/li&gt;
&lt;li&gt;可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。&lt;/li&gt;
&lt;li&gt;锁超时:和本地锁一样支持锁超时，防止死锁。&lt;/li&gt;
&lt;li&gt;高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。&lt;/li&gt;
&lt;li&gt;支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。&lt;/li&gt;
&lt;li&gt;支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;常见实现方式&#34;&gt;常见实现方式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MySql&lt;/li&gt;
&lt;li&gt;ZK/etcd&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Chubby&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mysql&#34;&gt;mysql&lt;/h2&gt;

&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;

&lt;p&gt;利用mysql的事务可以实现分布式资源的互斥访问，一般可以建立一个锁表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE `lock_table` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `resourcce_name` varchar(128) DEFAULT &#39;&#39;&#39;&#39;&#39;&#39; COMMENT &#39;资源名称&#39;,
  `node_info` varchar(128) DEFAULT NULL COMMENT &#39;机器信息&#39;,
  `count` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;锁的次数，统计可重入锁&#39;,
  `desc` varchar(128) DEFAULT NULL COMMENT &#39;额外的描述信息&#39;,
  `utime` int(11) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;更新时间戳&#39;,
  `ctime` int(11) unsigned NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;创建时间戳&#39;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uniq_resource` (`resourcce_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Lock&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transcation
public void lock(resourceName){
  if (select * from lock_table where resource_name = resourceName;有数据){
    if(node_info == currentNode){
      update lock_table set count=count+1 where resource_name = resourceName；
      return true；
    }else{
      return false;
    }
  }else{
    insert into lock_table;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用了sql的事务，获取锁时，先去查询锁是否存在，如果存在则比较node_info【ip+线程id】是否一致。如果一致就加可重入锁count的值，如果不一致那么就返回false。如果没有值，则可以创建这个锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tryLock:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean tryLock(){
  return mysqlLock.lock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;tryLock(timeout)&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean tryLock(long timeout){
  long endtime = timenow + timeout;
  while(true){
    if mysqlLock.lock(){
      return true;
    }
    if(timenow &amp;gt; endtime){
      return false;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;unlock()&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Transcation
public boolean unlock(){
  if(select * from lock_table 有数据){
    if(currentNode == node_info){
      if (count&amp;gt;1){
        update count = count-1;
      }else{
        delete;
      }
    }else{
      return false;
    }
  }else{
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;锁超时&lt;/strong&gt;：如果持有锁的节点挂了，那么该锁就不会被释放，我们可以启动一个定时任务来认定节点挂了之后释放锁。&lt;/p&gt;

&lt;h2 id=&#34;etcd&#34;&gt;etcd&lt;/h2&gt;

&lt;h3 id=&#34;事务-1&#34;&gt;事务&lt;/h3&gt;

&lt;p&gt;etcd3中可以序列化多个操作为一个条件性的迷你事务。每个事务包含一组条件守护的组合，当所有提交满足时一组操作被执行，并且任何条件不满足时另外一组操作被执行。事务可以保证分布式锁的安全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Txn().If(cond1, cond2, ...).Then(op1, op2, ...,).Else(op1’, op2’, …)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;etcd3中的事务有三个部分，条件块，&lt;code&gt;If(cond1,cond2,...)&lt;/code&gt; ,成功块 &lt;code&gt;Then(op1,op2,...)&lt;/code&gt;,失败块&lt;code&gt;Else(op1,op2,...)&lt;/code&gt; 条件块中的所有条件都满足的情况下就执行Then，否则就执行Else。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func doTxnXfer(etcd *v3.Client, from, to string, amount uint) (bool, error) {
    getresp, err := etcd.Txn(ctx.TODO()).Then(OpGet(from), OpGet(to)).Commit()	//事务查出from和get
    if err != nil {
         return false, err
    }
    fromKV := getresp.Responses[0].GetRangeResponse().Kvs[0]
    toKV := getresp.Responses[1].GetRangeResponse().Kvs[1]
    fromV, toV := toUInt64(fromKV.Value), toUint64(toKV.Value)
    if fromV &amp;lt; amount {
        return false, fmt.Errorf(“insufficient value”)
    }
    txn := etcd.Txn(ctx.TODO()).If(
        v3.Compare(v3.ModRevision(from), “=”, fromKV.ModRevision),
        v3.Compare(v3.ModRevision(to), “=”, toKV.ModRevision))			//如果from 和 get还没被修改
    txn = txn.Then(
        OpPut(from, fromUint64(fromV - amount)),					//那么久同时更新这两个key
        OpPut(to, fromUint64(toV + amount))
    putresp, err := txn.Commit()												//提交事务
    if err != nil {
        return false, err
    }
    return putresp.Succeeded, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://coreos.com/sites/default/files/inline-images/diagram3.png&#34; alt=&#34;diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而利用etcd的事务实现分布式锁的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package concurrency

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;sync&amp;quot;

	v3 &amp;quot;go.etcd.io/etcd/clientv3&amp;quot;
	pb &amp;quot;go.etcd.io/etcd/etcdserver/etcdserverpb&amp;quot;
)

// Mutex implements the sync Locker interface with etcd
type Mutex struct {
	s *Session

	pfx   string
	myKey string
	myRev int64
	hdr   *pb.ResponseHeader
}

func NewMutex(s *Session, pfx string) *Mutex {
	return &amp;amp;Mutex{s, pfx + &amp;quot;/&amp;quot;, &amp;quot;&amp;quot;, -1, nil}
}

// Lock locks the mutex with a cancelable context. If the context is canceled
// while trying to acquire the lock, the mutex tries to clean its stale lock entry.
func (m *Mutex) Lock(ctx context.Context) error {
	s := m.s
	client := m.s.Client()

	m.myKey = fmt.Sprintf(&amp;quot;%s%x&amp;quot;, m.pfx, s.Lease())
	cmp := v3.Compare(v3.CreateRevision(m.myKey), &amp;quot;=&amp;quot;, 0)
	// put self in lock waiters via myKey; oldest waiter holds lock
	put := v3.OpPut(m.myKey, &amp;quot;&amp;quot;, v3.WithLease(s.Lease()))
	// reuse key in case this session already holds the lock
	get := v3.OpGet(m.myKey)
	// fetch current holder to complete uncontended path with only one RPC
	getOwner := v3.OpGet(m.pfx, v3.WithFirstCreate()...)
	resp, err := client.Txn(ctx).If(cmp).Then(put, getOwner).Else(get, getOwner).Commit()
  //类似于原子操作cas，compare and swap
	if err != nil {
		return err
	}
	m.myRev = resp.Header.Revision
	if !resp.Succeeded {
		m.myRev = resp.Responses[0].GetResponseRange().Kvs[0].CreateRevision
	}
	// if no key on prefix / the minimum rev is key, already hold the lock
	ownerKey := resp.Responses[1].GetResponseRange().Kvs
	if len(ownerKey) == 0 || ownerKey[0].CreateRevision == m.myRev {
		m.hdr = resp.Header
		return nil
	}

	// wait for deletion revisions prior to myKey
	hdr, werr := waitDeletes(ctx, client, m.pfx, m.myRev-1)
	// release lock key if wait failed
	if werr != nil {
		m.Unlock(client.Ctx())
	} else {
		m.hdr = hdr
	}
	return werr
}

func (m *Mutex) Unlock(ctx context.Context) error {
	client := m.s.Client()
	if _, err := client.Delete(ctx, m.myKey); err != nil {
		return err
	}
	m.myKey = &amp;quot;\x00&amp;quot;
	m.myRev = -1
	return nil
}

func (m *Mutex) IsOwner() v3.Cmp {
	return v3.Compare(v3.CreateRevision(m.myKey), &amp;quot;=&amp;quot;, m.myRev)
}

func (m *Mutex) Key() string { return m.myKey }

// Header is the response header received from etcd on acquiring the lock.
func (m *Mutex) Header() *pb.ResponseHeader { return m.hdr }

type lockerMutex struct{ *Mutex }

func (lm *lockerMutex) Lock() {
	client := lm.s.Client()
	if err := lm.Mutex.Lock(client.Ctx()); err != nil {
		panic(err)
	}
}
func (lm *lockerMutex) Unlock() {
	client := lm.s.Client()
	if err := lm.Mutex.Unlock(client.Ctx()); err != nil {
		panic(err)
	}
}

// NewLocker creates a sync.Locker backed by an etcd mutex.
func NewLocker(s *Session, pfx string) sync.Locker {
	return &amp;amp;lockerMutex{NewMutex(s, pfx)}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;redis&#34;&gt;redis&lt;/h2&gt;

&lt;h3 id=&#34;单节点redis锁&#34;&gt;单节点redis锁&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;SET resource_name my_random_value NX PX 30000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的&lt;code&gt;SET&lt;/code&gt;命令中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;my_random_value&lt;/code&gt;是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NX&lt;/code&gt;表示只有当&lt;code&gt;resource_name&lt;/code&gt;对应的key值不存在的时候才能&lt;code&gt;SET&lt;/code&gt;成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PX 30000&lt;/code&gt;表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来&lt;strong&gt;释放锁&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if redis.call(&amp;quot;get&amp;quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&amp;quot;del&amp;quot;,KEYS[1])
else
    return 0
end复制代码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段Lua脚本在执行的时候要把前面的&lt;code&gt;my_random_value&lt;/code&gt;作为&lt;code&gt;ARGV[1]&lt;/code&gt;的值传进去，把&lt;code&gt;resource_name&lt;/code&gt;作为&lt;code&gt;KEYS[1]&lt;/code&gt;的值传进去.&lt;/p&gt;

&lt;p&gt;有几个点要注意下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;锁的过期时间，如果一个客户端获取到锁只有崩溃了，那么其他客户端再也不能获取到这个锁。所以要设置这个有效时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置一个随机字符串 my_random_value很有必要，这保证一个客户端释放的锁是自己持有的那个锁。假如获取锁时&lt;code&gt;SET&lt;/code&gt;的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端1获取锁成功。&lt;/li&gt;
&lt;li&gt;客户端1在某个操作上阻塞了很长时间。&lt;/li&gt;
&lt;li&gt;过期时间到了，锁自动释放了。&lt;/li&gt;
&lt;li&gt;客户端2获取到了对应同一个资源的锁。&lt;/li&gt;
&lt;li&gt;客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;释放锁的过程：释放锁的过程必须使用lua脚本或（multi）来实现。释放锁其实包含三步操作：&amp;rsquo;GET&amp;rsquo;、判断和&amp;rsquo;DEL&amp;rsquo;，用Lua脚本来实现能保证这三步的原子性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;redlock&#34;&gt;redlock&lt;/h3&gt;

&lt;p&gt;我们想象一个这样的场景当机器A申请到一把锁之后，如果Redis主宕机了，这个时候从机并没有同步到这一把锁，那么机器B再次申请的时候就会再次申请到这把锁，为了解决这个问题Redis作者提出了RedLock红锁的算法,在Redission中也对RedLock进行了实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//三个redis的集群
Rlock lock1 = redissonInstance1.getLock(&amp;quot;lock1&amp;quot;);
Rlock lock2 = redissonInstance2.getLock(&amp;quot;lock2&amp;quot;);
Rlock lock3 = redissonInstance3.getLock(&amp;quot;lock3&amp;quot;);

RedissonRedLock lock = new REdissonRedLock(lock1,lock2,lock3);
lock.lock();
  ...
lock.unlock();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的代码，我们需要实现多个Redis集群，然后进行红锁的加锁，解锁。具体的步骤如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先生成多个Redis集群的Rlock，并将其构造成RedLock。&lt;/li&gt;
&lt;li&gt;依次循环对三个集群进行加锁，加锁的过程和5.2里面一致。&lt;/li&gt;
&lt;li&gt;如果循环加锁的过程中加锁失败，那么需要判断加锁失败的次数是否超出了最大值，这里的最大值是根据集群的个数，比如三个那么只允许失败一个，五个的话只允许失败两个，要保证多数成功。&lt;/li&gt;
&lt;li&gt;加锁的过程中需要判断是否加锁超时，有可能我们设置加锁只能用3ms，第一个集群加锁已经消耗了3ms了。那么也算加锁失败。&lt;/li&gt;
&lt;li&gt;3，4步里面加锁失败的话，那么就会进行解锁操作，解锁会对所有的集群在请求一次解锁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以看见RedLock基本原理是利用多个Redis集群，用&lt;strong&gt;多数&lt;/strong&gt;的集群加锁成功，减少Redis某个集群出故障，造成分布式锁出现问题的概率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redis锁小结&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点:对于Redis实现简单，性能对比ZK和Mysql较好。如果不需要特别复杂的要求，那么自己就可以利用setNx进行实现，如果自己需要复杂的需求的话那么可以利用或者借鉴Redission。对于一些要求比较严格的场景来说的话可以使用RedLock。&lt;/li&gt;
&lt;li&gt;缺点:需要维护Redis集群，如果要实现RedLock那么需要维护更多的集群。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>部署ngrok</title>
      <link>https://kphn.github.io/post/2019/%E9%83%A8%E7%BD%B2ngrok/</link>
      <pubDate>Sun, 30 Jun 2019 15:37:14 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E9%83%A8%E7%BD%B2ngrok/</guid>
      
        <description>

&lt;h2 id=&#34;ngrok&#34;&gt;ngrok&lt;/h2&gt;

&lt;p&gt;ngrok可以让本地的web服务或tcp服务和外部建立一个安全的通道，使得外网可以访问本地的计算机服务。不仅可以用来暴露内网的http给外网使用，还可以从外网来ssh到本机开发环境。ngrok可以通过官方的服务来连接，也可以自己来。下面介绍下私有的ngrok服务的搭建工作。&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;搭建ngrok服务需要一个&lt;strong&gt;外网服务器&lt;/strong&gt;以及一个已经解析到了该机器的&lt;strong&gt;域名&lt;/strong&gt;（假定为test.site）,国内可以在阿里云购买相关服务：&lt;a href=&#34;https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mwdh54s4&#34;&gt;阿里云&lt;/a&gt;。注意：下文中用到的所有端口，如果启用了iptables规则，都需要放行，如果在阿里云中，需要设置&lt;strong&gt;安全组规则&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;依赖项&#34;&gt;依赖项&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;ngrok使用go语言开发，所以首先要 安装go语言：&lt;a href=&#34;https://golang.org/doc/install&#34;&gt;https://golang.org/doc/install&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;下载代码：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a href=&#34;https://github.com/inconshreveable/ngrok.git&#34;&gt;https://github.com/inconshreveable/ngrok.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成ssl证书：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;cd ngrok&lt;/p&gt;

&lt;p&gt;NGROK_DOMAIN=&amp;ldquo;test.site&amp;rdquo;&lt;/p&gt;

&lt;p&gt;openssl genrsa -out base.key 2048&lt;/p&gt;

&lt;p&gt;openssl req -new -x509 -nodes -key base.key -days 10000 -subj &amp;ldquo;/CN=$NGROK_DOMAIN&amp;rdquo; -out base.pem&lt;/p&gt;

&lt;p&gt;openssl genrsa -out server.key 2048&lt;/p&gt;

&lt;p&gt;openssl req -new -key server.key -subj &amp;ldquo;/CN=$NGROK_DOMAIN&amp;rdquo; -out server.csr&lt;/p&gt;

&lt;p&gt;openssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt&lt;/p&gt;

&lt;p&gt;cp base.pem assets/client/tls/ngrokroot.crt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;sudo make release-server release-client&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时在bin目录下应该有ngrok和ngrokd两个可执行文件。&lt;/p&gt;

&lt;p&gt;如果需要交叉编译：先设置好GOOS与GOARCH变量&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Linux 平台 32 位系统：GOOS=linux GOARCH=386&lt;/p&gt;

&lt;p&gt;Linux 平台 64 位系统：GOOS=linux GOARCH=amd64&lt;/p&gt;

&lt;p&gt;Windows 平台 32 位系统：GOOS=windows GOARCH=386&lt;/p&gt;

&lt;p&gt;Windows 平台 64 位系统：GOOS=windows GOARCH=amd64&lt;/p&gt;

&lt;p&gt;MAC 平台 32 位系统：GOOS=darwin GOARCH=386&lt;/p&gt;

&lt;p&gt;MAC 平台 64 位系统：GOOS=darwin GOARCH=amd64&lt;/p&gt;

&lt;p&gt;如需要编译window 64位版本：
GOOS=windows GOARCH=amd64 make release-client&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务端启动：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;nohup ./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&amp;ldquo;test.site&amp;rdquo; -httpAddr=&amp;rdquo;:8081&amp;rdquo; -httpsAddr=&amp;rdquo;:8082&amp;rdquo; &amp;amp;&lt;/p&gt;

&lt;p&gt;示例中8081用来连接http请求，8082用来连接https请求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;客户端启动：&lt;/p&gt;

&lt;p&gt;将编译好的client版本下载到指定的机器上之后，配置启动文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;server_addr: test.site:4443			//4443为ngrok控制tunnel
trust_host_root_certs: false		//如果不需要使用TLS，可以将此变量设置为你false
tunnels:
  client:
    subdomain: pub
    proto:
      http: 8080
  ssh:
    remote_port: 2022
    proto:
      tcp: 22
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;./ngrok -log=stdout -config=ngrok.yml start ssh client&amp;amp;  启动客户端&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;此时，会把本机的8080端口的服务映射到服务端pub.test.site:8081端口，便可以用来访问客户端的8080端口的服务了。&lt;/p&gt;

&lt;p&gt;tcp tunnel将22端口映射到服务端的2022端口，便可以ssh user@test.site -p2022 来访问客户端的ssh服务了。&lt;/p&gt;

&lt;p&gt;开机启动ngrok client：&lt;/p&gt;

&lt;p&gt;首先编写启动脚本 ngrok.sh：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /path/to/ngrok-client
./ngrok -log=stdout -config=ngrok.yml start ssh&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再配置systemd ngrok service文件 /usr/lib/systemd/system/ngrok.service；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=ngrok service

[Service]
Type=forking
ExecStart=/bin/bash /path/to/ngrok.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable ngrok.service
systemctl start ngrok.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务就可以开机启动了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://kphn.github.io/post/2019/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:41:18 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;如果要使用继承关心，必须严格遵循里氏替换原则。&lt;/code&gt;合成复用原则同里氏替换原则是相辅相成的，两者都是开闭原则的具体实现规范。&lt;/p&gt;

&lt;h2 id=&#34;重要性&#34;&gt;重要性&lt;/h2&gt;

&lt;p&gt;通常类的复用分为继承复用和组合复用两种，继承复用虽然有简单和易实现的优点，但也存在以下缺点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;继承复用&lt;strong&gt;&lt;em&gt;破坏了类的封装性&lt;/em&gt;&lt;/strong&gt;。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子类与父类的耦合度高&lt;/strong&gt;。父类的实现的任何改变都会&lt;strong&gt;&lt;em&gt;导致子类的实现发生变化&lt;/em&gt;&lt;/strong&gt;，这不利于类的扩展与维护。&lt;/li&gt;
&lt;li&gt;它限制了复用的灵活性。从父类继承而来的实现是静态的，在&lt;strong&gt;&lt;em&gt;编译时已经定义&lt;/em&gt;&lt;/strong&gt;，所以在运行时不可能发生变化。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。&lt;/li&gt;
&lt;li&gt;新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。&lt;/li&gt;
&lt;li&gt;复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;共介绍了7种设计原则，它们分别为&lt;a href=&#34;https://kphn.github.io/post/open-close/&#34;&gt;开闭原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/里氏替换原则&#34;&gt;里氏替换原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/依赖倒置原则/&#34;&gt;依赖倒置原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/单一职责/&#34;&gt;单一职责原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/接口隔离原则&#34;&gt;接口隔离原则&lt;/a&gt;、&lt;a href=&#34;https://kphn.github.io/post/迪米特法则/&#34;&gt;迪米特法则&lt;/a&gt;和本节所介绍的合成复用原则。&lt;/p&gt;

&lt;p&gt;这 7 种设计原则是软件&lt;a href=&#34;https://kphn.github.io/post/设计模式/&#34;&gt;设计模式&lt;/a&gt;必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://kphn.github.io/post/2019/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:27:57 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;迪米特法则（Law of Demeter）：又称最少知识原则（Least Knowledge Principle，LKP），只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。&lt;/p&gt;

&lt;p&gt;迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。&lt;/p&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;降低了类之间的耦合度，提高了模块的相对独立性。&lt;/li&gt;
&lt;li&gt;由于亲和度降低，从而提高了类的可复用率和系统的扩展性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，过度使用迪米特法则会使系统产生大量的&lt;strong&gt;中介类(Agent)&lt;/strong&gt;，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在采用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。&lt;/p&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;从迪米特法则的定义和特点可知，它强调以下两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从依赖者的角度来说，只依赖应该依赖的对象。&lt;/li&gt;
&lt;li&gt;从被依赖者的角度说，只暴露应该暴露的方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以，在运用迪米特法则时要注意以下 6 点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。&lt;/li&gt;
&lt;li&gt;在类的结构设计上，尽量降低类成员的访问权限。&lt;/li&gt;
&lt;li&gt;在类的设计上，优先考虑将一个类设置成不变类。&lt;/li&gt;
&lt;li&gt;在对其他类的引用上，将引用其他对象的次数降到最低。&lt;/li&gt;
&lt;li&gt;不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。&lt;/li&gt;
&lt;li&gt;谨慎使用序列化（Serializable）功能。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>接口隔离原则</title>
      <link>https://kphn.github.io/post/2019/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 28 Jun 2019 08:16:33 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小和更具体的接口，让接口中只包含客户感兴趣的方法。定义：客户端不应该被迫依赖于它不适用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。&lt;/p&gt;

&lt;p&gt;以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。&lt;/p&gt;

&lt;p&gt;接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。&lt;/li&gt;
&lt;li&gt;单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;p&gt;接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。&lt;/li&gt;
&lt;li&gt;接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。&lt;/li&gt;
&lt;li&gt;如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。&lt;/li&gt;
&lt;li&gt;使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。&lt;/li&gt;
&lt;li&gt;能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑&lt;/li&gt;
&lt;li&gt;为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。&lt;/li&gt;
&lt;li&gt;了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，深入了解业务逻辑。&lt;/li&gt;
&lt;li&gt;提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>单一职责原则</title>
      <link>https://kphn.github.io/post/2019/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</link>
      <pubDate>Fri, 28 Jun 2019 08:05:42 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则：规定一个类应该且仅有一个引起它变化的原因，否则类应该被拆分。&lt;/p&gt;

&lt;p&gt;该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；&lt;/li&gt;
&lt;li&gt;当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全部包含进来，从而造成冗余代码或代码的浪费。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;优点&#34;&gt;优点&lt;/h2&gt;

&lt;p&gt;单一职责原则的核心就是&lt;strong&gt;控制类的粒度大小&lt;/strong&gt;、将对象&lt;strong&gt;解耦、提高其内聚性&lt;/strong&gt;。如果遵循单一职责原则将有以下优点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;降低类的复杂度。一个类只负责一项职责。&lt;/li&gt;
&lt;li&gt;提高类的可读性。&lt;/li&gt;
&lt;li&gt;提高系统的可维护性。&lt;/li&gt;
&lt;li&gt;变更引起的风险降低。当修改一个功能时，可以显著降低对其他功能的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;单一职责原则是最简单但又比较难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或者模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>依赖倒置原则</title>
      <link>https://kphn.github.io/post/2019/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 27 Jun 2019 08:42:55 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</guid>
      
        <description>

&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;

&lt;p&gt;依赖倒置原则（Dependence Inversion Principle，DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是&lt;code&gt;面向接口编程，不要面向实现编程&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节搭建起来的架构稳定的多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。&lt;/p&gt;

&lt;p&gt;使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。&lt;/p&gt;

&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;依赖倒置降低了类间的耦合性&lt;/li&gt;
&lt;li&gt;依赖倒置提高了系统的稳定性&lt;/li&gt;
&lt;li&gt;依赖倒置减少并行开发引起的风险&lt;/li&gt;
&lt;li&gt;依赖倒置提高了代码的可读性和可维护性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;实现方法&#34;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;依赖倒置原则的目的是通过面向接口的编程来降低类间的耦合性&lt;/code&gt;，需要遵循以下几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;每个类尽量提供接口或抽象类，或者两者都具备&lt;/li&gt;
&lt;li&gt;变量的声明类型尽量是接口或者是抽象类&lt;/li&gt;
&lt;li&gt;任何类都不应该从抽象类派生&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用继承时尽量遵循里氏替换原则&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package principle;
public class DIPtest
{
public static void main(String[] args)
{
    Customer wang=new Customer();
    System.out.println(&amp;quot;顾客购买以下商品：&amp;quot;); 
    wang.shopping(new ShaoguanShop()); 
    wang.shopping(new WuyuanShop());
}
}
//商店
interface Shop
{
public String sell(); //卖
}
//韶关网店
class ShaoguanShop implements Shop
{
public String sell()
{
    return &amp;quot;韶关土特产：香菇、木耳……&amp;quot;; 
} 
}
//婺源网店
class WuyuanShop implements Shop
{
public String sell()
{
    return &amp;quot;婺源土特产：绿茶、酒糟鱼……&amp;quot;; 
}
} 
//顾客
class Customer
{
public void shopping(Shop shop)
{
    //购物
    System.out.println(shop.sell()); 
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>开放闭合原则</title>
      <link>https://kphn.github.io/post/2019/open-close/</link>
      <pubDate>Wed, 26 Jun 2019 23:17:56 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/open-close/</guid>
      
        <description>

&lt;h2 id=&#34;开闭原则&#34;&gt;开闭原则&lt;/h2&gt;

&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;

&lt;p&gt;OCP（Open Closed Principle）：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）。&lt;/p&gt;

&lt;p&gt;这里的软件实体包括以下几个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;项目中划分出的模块&lt;/li&gt;
&lt;li&gt;类与接口&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。&lt;/p&gt;

&lt;h3 id=&#34;作用与实现方法&#34;&gt;作用与实现方法&lt;/h3&gt;

&lt;p&gt;开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。
可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://kphn.github.io/post/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 26 Jun 2019 08:25:28 +0800</pubDate>
      
      <guid>https://kphn.github.io/post/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;设计模式是前辈们对于代码开发经验的总结，是解决特定问题的一种固定套路。本质上还是对面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。设计模式最终要做到的就是&lt;strong&gt;将变化的部分和不变的部分隔离开来&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;设计模式有两个核心理念：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Program to an “interface”,not an &amp;ldquo;implementation&amp;rdquo;

&lt;ol&gt;
&lt;li&gt;使用者不需要知道数据类型，结构，算法的细节&lt;/li&gt;
&lt;li&gt;使用者不需要知道实现细节，只需要知道提供的接口&lt;/li&gt;
&lt;li&gt;利于抽象，封装，动态绑定，多态&lt;/li&gt;
&lt;li&gt;符合面向对象的特质和理念&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Favor &amp;lsquo;object composition&amp;rsquo; over &amp;lsquo;class inheritance&amp;rsquo;&amp;rdquo;

&lt;ol&gt;
&lt;li&gt;继承需要给子类暴漏一些父类的设计和实现细节&lt;/li&gt;
&lt;li&gt;父类实现的改变会造成子类也需要改变&lt;/li&gt;
&lt;li&gt;我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法&lt;/li&gt;
&lt;li&gt;继承更多的应该是为了多态&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tips&#34;&gt;TIPS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;封装变化&lt;/li&gt;
&lt;li&gt;多用组合，少用继承&lt;/li&gt;
&lt;li&gt;针对接口编程，不针对实现编程&lt;/li&gt;
&lt;li&gt;将系统中变化的部分抽离出来封装&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导航&#34;&gt;导航&lt;/h2&gt;

&lt;p&gt;接下来，我将具体的深入到每个设计模式当中去，去探究其使用场景&lt;/p&gt;

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;面向对象设计原则

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/open-close/&#34;&gt;开放闭合原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/里氏替换原则&#34;&gt;里氏替换原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/依赖倒置原则/&#34;&gt;依赖倒置原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/单一职责/&#34;&gt;单一职责原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/接口隔离原则&#34;&gt;接口隔离原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/迪米特法则/&#34;&gt;迪米特法则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://kphn.github.io/post/合成复用原则/&#34;&gt;合成复用原则&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;设计模式详解

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;创建性模式&lt;/li&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;行为型模式

&lt;ol class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; [观察者模式]()&lt;/label&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/design_pattern/&#34;&gt;Java设计模式：23种设计模式全面解析（超级详细）&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
